<?php
/**
 * ReviewApi
 * PHP version 5
 *
 * @category Class
 * @package  Immodvisor
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API Immodvisor
 *
 * ## Terms of use    \\n\\nThe terms of use gather all the rules to follow to use the Immodvisor API. ## Technical side Your API key and the grains of salt of the checksums must remain secret, they represent your private parameters. It is strictly forbidden to communicate them to third parties. For security reasons, if one of these rules is not respected, we would be forced to deactivate your API key. ## Advices It is strongly recommended to use cache if you are using the API to display your rating and reviews on your site. This will ensure that the display of your page does not depend on the API responses and therefore does not affect its display time. ## Display the notices on your media ### On your website: You must clearly display the source of the reviews, namely Immodvisor. Thus, the Immodvisor logo or the seal of trust must clearly appear on the page displaying the reviews, with a link in the href, scanned by search engines, and pointing to the company file of the Immodvisor site. This point is essential for search engines to make the link between the 2 pages, and avoid duplication of content. The review pages of your site must be validated by our marketing department before going into production. You must also display a textual mention indicating that the reviews come from the Immodvisor site.   Our marketing department can be reached at 09 81 10 75 88 or by email at assistance@Immodvisor.com ### On other communication supports: You must always display the Immodvisor logo and indicate that the reviews are from the Immodvisor solution.  ## Display Rich Snippets in google results on your url Rich Snippets give the promise to the internet user to be able to read reviews. Any page displaying Rich Snippets in google must display the stars, as well as a link to the company's Immodvisor page. All these elements must match. For example, you can display the Rich Snippets of the company on the home page, and the Rich Snippets of each agency on your respective agency pages. Strong recommendation: a given Rich Snippet should only be placed on one and only one web page. Good to know: Rich Snippets tell Google's search engine a rating related to a web page. Google decides whether or not displaying the note in its search results is relevant to your web page. Immodvisor cannot influence Google's willingness to display or not the indicators sent by your site. ## Checksum For each call to the API, a checksum must be sent. This checksum is calculated as follows:   Concatenation of the following values, all formatted in SHA1 :  * apikey * values of the sent fields, formatted in JSON if it is an array or an object * checksum_salt_in  ### PHP code example ```PHP private function calcChecksumIn($api_key, $checksum_salt_in, $datas = array())     {         $checksum = \"\";         $checksum .= $api_key;         foreach ($datas as $k => $v) {             if (is_array($v) || is_object($v)) {                 $v = json_encode($v, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);             } elseif ($v === true) {                 $v = 1;             } elseif ($v === false) {                 $v = 0;             }             $checksum .= $v;         }         $checksum .= $checksum_salt_in;         return sha1($checksum);     }   ```
 *
 * OpenAPI spec version: 1.11.0
 * Contact: assistance@Immodvisor.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.56
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Immodvisor\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Immodvisor\ApiException;
use Immodvisor\Configuration;
use Immodvisor\HeaderSelector;
use Immodvisor\ObjectSerializer;

/**
 * ReviewApi Class Doc Comment
 *
 * @category Class
 * @package  Immodvisor
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ReviewApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation reviewCollectPost
     *
     * send request for an reviews
     *
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  int $companyId companyId (optional)
     * @param  int $companyCustomId companyCustomId (optional)
     * @param  string $email email (optional)
     * @param  string $mobile mobile (optional)
     * @param  string $firstname firstname (optional)
     * @param  string $lastname lastname (optional)
     * @param  int $proId proId (optional)
     * @param  string $proCustomId proCustomId (optional)
     * @param  int $activityId activityId (optional)
     * @param  int $highlightNumber highlightNumber (optional)
     * @param  string $customRef customRef (optional)
     * @param  int $folderId folderId (optional)
     * @param  string $lang lang (optional)
     * @param  string $checksum checksum (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Immodvisor\Model\InlineResponse2004
     */
    public function reviewCollectPost($aPIVERSION, $companyId = null, $companyCustomId = null, $email = null, $mobile = null, $firstname = null, $lastname = null, $proId = null, $proCustomId = null, $activityId = null, $highlightNumber = null, $customRef = null, $folderId = null, $lang = null, $checksum = null)
    {
        list($response) = $this->reviewCollectPostWithHttpInfo($aPIVERSION, $companyId, $companyCustomId, $email, $mobile, $firstname, $lastname, $proId, $proCustomId, $activityId, $highlightNumber, $customRef, $folderId, $lang, $checksum);
        return $response;
    }

    /**
     * Operation reviewCollectPostWithHttpInfo
     *
     * send request for an reviews
     *
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  int $companyId (optional)
     * @param  int $companyCustomId (optional)
     * @param  string $email (optional)
     * @param  string $mobile (optional)
     * @param  string $firstname (optional)
     * @param  string $lastname (optional)
     * @param  int $proId (optional)
     * @param  string $proCustomId (optional)
     * @param  int $activityId (optional)
     * @param  int $highlightNumber (optional)
     * @param  string $customRef (optional)
     * @param  int $folderId (optional)
     * @param  string $lang (optional)
     * @param  string $checksum (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Immodvisor\Model\InlineResponse2004, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewCollectPostWithHttpInfo($aPIVERSION, $companyId = null, $companyCustomId = null, $email = null, $mobile = null, $firstname = null, $lastname = null, $proId = null, $proCustomId = null, $activityId = null, $highlightNumber = null, $customRef = null, $folderId = null, $lang = null, $checksum = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse2004';
        $request = $this->reviewCollectPostRequest($aPIVERSION, $companyId, $companyCustomId, $email, $mobile, $firstname, $lastname, $proId, $proCustomId, $activityId, $highlightNumber, $customRef, $folderId, $lang, $checksum);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse2004',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewCollectPostAsync
     *
     * send request for an reviews
     *
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  int $companyId (optional)
     * @param  int $companyCustomId (optional)
     * @param  string $email (optional)
     * @param  string $mobile (optional)
     * @param  string $firstname (optional)
     * @param  string $lastname (optional)
     * @param  int $proId (optional)
     * @param  string $proCustomId (optional)
     * @param  int $activityId (optional)
     * @param  int $highlightNumber (optional)
     * @param  string $customRef (optional)
     * @param  int $folderId (optional)
     * @param  string $lang (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewCollectPostAsync($aPIVERSION, $companyId = null, $companyCustomId = null, $email = null, $mobile = null, $firstname = null, $lastname = null, $proId = null, $proCustomId = null, $activityId = null, $highlightNumber = null, $customRef = null, $folderId = null, $lang = null, $checksum = null)
    {
        return $this->reviewCollectPostAsyncWithHttpInfo($aPIVERSION, $companyId, $companyCustomId, $email, $mobile, $firstname, $lastname, $proId, $proCustomId, $activityId, $highlightNumber, $customRef, $folderId, $lang, $checksum)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewCollectPostAsyncWithHttpInfo
     *
     * send request for an reviews
     *
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  int $companyId (optional)
     * @param  int $companyCustomId (optional)
     * @param  string $email (optional)
     * @param  string $mobile (optional)
     * @param  string $firstname (optional)
     * @param  string $lastname (optional)
     * @param  int $proId (optional)
     * @param  string $proCustomId (optional)
     * @param  int $activityId (optional)
     * @param  int $highlightNumber (optional)
     * @param  string $customRef (optional)
     * @param  int $folderId (optional)
     * @param  string $lang (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewCollectPostAsyncWithHttpInfo($aPIVERSION, $companyId = null, $companyCustomId = null, $email = null, $mobile = null, $firstname = null, $lastname = null, $proId = null, $proCustomId = null, $activityId = null, $highlightNumber = null, $customRef = null, $folderId = null, $lang = null, $checksum = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse2004';
        $request = $this->reviewCollectPostRequest($aPIVERSION, $companyId, $companyCustomId, $email, $mobile, $firstname, $lastname, $proId, $proCustomId, $activityId, $highlightNumber, $customRef, $folderId, $lang, $checksum);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewCollectPost'
     *
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  int $companyId (optional)
     * @param  int $companyCustomId (optional)
     * @param  string $email (optional)
     * @param  string $mobile (optional)
     * @param  string $firstname (optional)
     * @param  string $lastname (optional)
     * @param  int $proId (optional)
     * @param  string $proCustomId (optional)
     * @param  int $activityId (optional)
     * @param  int $highlightNumber (optional)
     * @param  string $customRef (optional)
     * @param  int $folderId (optional)
     * @param  string $lang (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewCollectPostRequest($aPIVERSION, $companyId = null, $companyCustomId = null, $email = null, $mobile = null, $firstname = null, $lastname = null, $proId = null, $proCustomId = null, $activityId = null, $highlightNumber = null, $customRef = null, $folderId = null, $lang = null, $checksum = null)
    {
        // verify the required parameter 'aPIVERSION' is set
        if ($aPIVERSION === null || (is_array($aPIVERSION) && count($aPIVERSION) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $aPIVERSION when calling reviewCollectPost'
            );
        }

        $resourcePath = '/review/collect';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($aPIVERSION !== null) {
            $headerParams['APIVERSION'] = ObjectSerializer::toHeaderValue($aPIVERSION);
        }


        // form params
        if ($companyId !== null) {
            $formParams['company_id'] = ObjectSerializer::toFormValue($companyId);
        }
        // form params
        if ($companyCustomId !== null) {
            $formParams['company_custom_id'] = ObjectSerializer::toFormValue($companyCustomId);
        }
        // form params
        if ($email !== null) {
            $formParams['email'] = ObjectSerializer::toFormValue($email);
        }
        // form params
        if ($mobile !== null) {
            $formParams['mobile'] = ObjectSerializer::toFormValue($mobile);
        }
        // form params
        if ($firstname !== null) {
            $formParams['firstname'] = ObjectSerializer::toFormValue($firstname);
        }
        // form params
        if ($lastname !== null) {
            $formParams['lastname'] = ObjectSerializer::toFormValue($lastname);
        }
        // form params
        if ($proId !== null) {
            $formParams['pro_id'] = ObjectSerializer::toFormValue($proId);
        }
        // form params
        if ($proCustomId !== null) {
            $formParams['pro_custom_id'] = ObjectSerializer::toFormValue($proCustomId);
        }
        // form params
        if ($activityId !== null) {
            $formParams['activity_id'] = ObjectSerializer::toFormValue($activityId);
        }
        // form params
        if ($highlightNumber !== null) {
            $formParams['highlight_number'] = ObjectSerializer::toFormValue($highlightNumber);
        }
        // form params
        if ($customRef !== null) {
            $formParams['custom_ref'] = ObjectSerializer::toFormValue($customRef);
        }
        // form params
        if ($folderId !== null) {
            $formParams['folder_id'] = ObjectSerializer::toFormValue($folderId);
        }
        // form params
        if ($lang !== null) {
            $formParams['lang'] = ObjectSerializer::toFormValue($lang);
        }
        // form params
        if ($checksum !== null) {
            $formParams['checksum'] = ObjectSerializer::toFormValue($checksum);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('APIKEY');
        if ($apiKey !== null) {
            $headers['APIKEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewCollectmultiplePost
     *
     * multiple send request for reviews
     *
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  \Immodvisor\Model\ReviewcollectmultipleDatas[] $datas datas (optional)
     * @param  string $checksum checksum (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Immodvisor\Model\InlineResponse20012
     */
    public function reviewCollectmultiplePost($aPIVERSION, $datas = null, $checksum = null)
    {
        list($response) = $this->reviewCollectmultiplePostWithHttpInfo($aPIVERSION, $datas, $checksum);
        return $response;
    }

    /**
     * Operation reviewCollectmultiplePostWithHttpInfo
     *
     * multiple send request for reviews
     *
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  \Immodvisor\Model\ReviewcollectmultipleDatas[] $datas (optional)
     * @param  string $checksum (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Immodvisor\Model\InlineResponse20012, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewCollectmultiplePostWithHttpInfo($aPIVERSION, $datas = null, $checksum = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse20012';
        $request = $this->reviewCollectmultiplePostRequest($aPIVERSION, $datas, $checksum);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse20012',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewCollectmultiplePostAsync
     *
     * multiple send request for reviews
     *
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  \Immodvisor\Model\ReviewcollectmultipleDatas[] $datas (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewCollectmultiplePostAsync($aPIVERSION, $datas = null, $checksum = null)
    {
        return $this->reviewCollectmultiplePostAsyncWithHttpInfo($aPIVERSION, $datas, $checksum)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewCollectmultiplePostAsyncWithHttpInfo
     *
     * multiple send request for reviews
     *
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  \Immodvisor\Model\ReviewcollectmultipleDatas[] $datas (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewCollectmultiplePostAsyncWithHttpInfo($aPIVERSION, $datas = null, $checksum = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse20012';
        $request = $this->reviewCollectmultiplePostRequest($aPIVERSION, $datas, $checksum);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewCollectmultiplePost'
     *
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  \Immodvisor\Model\ReviewcollectmultipleDatas[] $datas (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewCollectmultiplePostRequest($aPIVERSION, $datas = null, $checksum = null)
    {
        // verify the required parameter 'aPIVERSION' is set
        if ($aPIVERSION === null || (is_array($aPIVERSION) && count($aPIVERSION) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $aPIVERSION when calling reviewCollectmultiplePost'
            );
        }

        $resourcePath = '/review/collectmultiple';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($aPIVERSION !== null) {
            $headerParams['APIVERSION'] = ObjectSerializer::toHeaderValue($aPIVERSION);
        }


        // form params
        if ($datas !== null) {
            $formParams['datas'] = ObjectSerializer::toFormValue($datas);
        }
        // form params
        if ($checksum !== null) {
            $formParams['checksum'] = ObjectSerializer::toFormValue($checksum);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('APIKEY');
        if ($apiKey !== null) {
            $headers['APIKEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewCreateAnswerPost
     *
     * Add an answer to a review
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $reviewId reviewId (optional)
     * @param  string $answer answer (optional)
     * @param  string $job job (optional)
     * @param  string $signature signature (optional)
     * @param  string $checksum checksum (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Immodvisor\Model\InlineResponse20013
     */
    public function reviewCreateAnswerPost($aPIVERSION, $reviewId = null, $answer = null, $job = null, $signature = null, $checksum = null)
    {
        list($response) = $this->reviewCreateAnswerPostWithHttpInfo($aPIVERSION, $reviewId, $answer, $job, $signature, $checksum);
        return $response;
    }

    /**
     * Operation reviewCreateAnswerPostWithHttpInfo
     *
     * Add an answer to a review
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $reviewId (optional)
     * @param  string $answer (optional)
     * @param  string $job (optional)
     * @param  string $signature (optional)
     * @param  string $checksum (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Immodvisor\Model\InlineResponse20013, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewCreateAnswerPostWithHttpInfo($aPIVERSION, $reviewId = null, $answer = null, $job = null, $signature = null, $checksum = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse20013';
        $request = $this->reviewCreateAnswerPostRequest($aPIVERSION, $reviewId, $answer, $job, $signature, $checksum);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse20013',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewCreateAnswerPostAsync
     *
     * Add an answer to a review
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $reviewId (optional)
     * @param  string $answer (optional)
     * @param  string $job (optional)
     * @param  string $signature (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewCreateAnswerPostAsync($aPIVERSION, $reviewId = null, $answer = null, $job = null, $signature = null, $checksum = null)
    {
        return $this->reviewCreateAnswerPostAsyncWithHttpInfo($aPIVERSION, $reviewId, $answer, $job, $signature, $checksum)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewCreateAnswerPostAsyncWithHttpInfo
     *
     * Add an answer to a review
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $reviewId (optional)
     * @param  string $answer (optional)
     * @param  string $job (optional)
     * @param  string $signature (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewCreateAnswerPostAsyncWithHttpInfo($aPIVERSION, $reviewId = null, $answer = null, $job = null, $signature = null, $checksum = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse20013';
        $request = $this->reviewCreateAnswerPostRequest($aPIVERSION, $reviewId, $answer, $job, $signature, $checksum);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewCreateAnswerPost'
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $reviewId (optional)
     * @param  string $answer (optional)
     * @param  string $job (optional)
     * @param  string $signature (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewCreateAnswerPostRequest($aPIVERSION, $reviewId = null, $answer = null, $job = null, $signature = null, $checksum = null)
    {
        // verify the required parameter 'aPIVERSION' is set
        if ($aPIVERSION === null || (is_array($aPIVERSION) && count($aPIVERSION) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $aPIVERSION when calling reviewCreateAnswerPost'
            );
        }

        $resourcePath = '/review/create-answer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($aPIVERSION !== null) {
            $headerParams['APIVERSION'] = ObjectSerializer::toHeaderValue($aPIVERSION);
        }


        // form params
        if ($reviewId !== null) {
            $formParams['review_id'] = ObjectSerializer::toFormValue($reviewId);
        }
        // form params
        if ($answer !== null) {
            $formParams['answer'] = ObjectSerializer::toFormValue($answer);
        }
        // form params
        if ($job !== null) {
            $formParams['job'] = ObjectSerializer::toFormValue($job);
        }
        // form params
        if ($signature !== null) {
            $formParams['signature'] = ObjectSerializer::toFormValue($signature);
        }
        // form params
        if ($checksum !== null) {
            $formParams['checksum'] = ObjectSerializer::toFormValue($checksum);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('APIKEY');
        if ($apiKey !== null) {
            $headers['APIKEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewEvidencePost
     *
     * Add an evidence
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $reviewId reviewId (optional)
     * @param  string $file file (optional)
     * @param  string $checksum checksum (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Immodvisor\Model\InlineResponse400
     */
    public function reviewEvidencePost($aPIVERSION, $reviewId = null, $file = null, $checksum = null)
    {
        list($response) = $this->reviewEvidencePostWithHttpInfo($aPIVERSION, $reviewId, $file, $checksum);
        return $response;
    }

    /**
     * Operation reviewEvidencePostWithHttpInfo
     *
     * Add an evidence
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $reviewId (optional)
     * @param  string $file (optional)
     * @param  string $checksum (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Immodvisor\Model\InlineResponse400, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewEvidencePostWithHttpInfo($aPIVERSION, $reviewId = null, $file = null, $checksum = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse400';
        $request = $this->reviewEvidencePostRequest($aPIVERSION, $reviewId, $file, $checksum);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewEvidencePostAsync
     *
     * Add an evidence
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $reviewId (optional)
     * @param  string $file (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewEvidencePostAsync($aPIVERSION, $reviewId = null, $file = null, $checksum = null)
    {
        return $this->reviewEvidencePostAsyncWithHttpInfo($aPIVERSION, $reviewId, $file, $checksum)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewEvidencePostAsyncWithHttpInfo
     *
     * Add an evidence
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $reviewId (optional)
     * @param  string $file (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewEvidencePostAsyncWithHttpInfo($aPIVERSION, $reviewId = null, $file = null, $checksum = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse400';
        $request = $this->reviewEvidencePostRequest($aPIVERSION, $reviewId, $file, $checksum);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewEvidencePost'
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $reviewId (optional)
     * @param  string $file (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewEvidencePostRequest($aPIVERSION, $reviewId = null, $file = null, $checksum = null)
    {
        // verify the required parameter 'aPIVERSION' is set
        if ($aPIVERSION === null || (is_array($aPIVERSION) && count($aPIVERSION) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $aPIVERSION when calling reviewEvidencePost'
            );
        }

        $resourcePath = '/review/evidence';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($aPIVERSION !== null) {
            $headerParams['APIVERSION'] = ObjectSerializer::toHeaderValue($aPIVERSION);
        }


        // form params
        if ($reviewId !== null) {
            $formParams['review_id'] = ObjectSerializer::toFormValue($reviewId);
        }
        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // form params
        if ($checksum !== null) {
            $formParams['checksum'] = ObjectSerializer::toFormValue($checksum);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('APIKEY');
        if ($apiKey !== null) {
            $headers['APIKEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewListGet
     *
     * Get company's reviews list
     *
     * @param  string $checksum Request&#x27;s validity checksum (required)
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  int $companyId unique Immodvisor company ID (optional)
     * @param  string $companyCustomId Your unique company&#x27;s ID. (optional)
     * @param  string $dateStart start date of the search (YYYY-MM-DD : year + month + day). The date indicated is included. If the start date is not indicated, then it takes the value of the date of creation of the company on Immodvisor. (optional)
     * @param  string $dateStop Search&#x27;s end date (same format accepted). If the end date is not filled in, then it takes the value of the current date. (optional)
     * @param  string $dateFilter Defines on which fields the dates are filtered :   * If not specified, filters dates based on the validation date   * If &#x27;update&#x27;, filters dates based on the last modification date (either validation, update or answer) (optional)
     * @param  bool $picking Filter reviews awaiting proof. (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Immodvisor\Model\InlineResponse20010
     */
    public function reviewListGet($checksum, $aPIVERSION, $companyId = null, $companyCustomId = null, $dateStart = null, $dateStop = null, $dateFilter = null, $picking = null)
    {
        list($response) = $this->reviewListGetWithHttpInfo($checksum, $aPIVERSION, $companyId, $companyCustomId, $dateStart, $dateStop, $dateFilter, $picking);
        return $response;
    }

    /**
     * Operation reviewListGetWithHttpInfo
     *
     * Get company's reviews list
     *
     * @param  string $checksum Request&#x27;s validity checksum (required)
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  int $companyId unique Immodvisor company ID (optional)
     * @param  string $companyCustomId Your unique company&#x27;s ID. (optional)
     * @param  string $dateStart start date of the search (YYYY-MM-DD : year + month + day). The date indicated is included. If the start date is not indicated, then it takes the value of the date of creation of the company on Immodvisor. (optional)
     * @param  string $dateStop Search&#x27;s end date (same format accepted). If the end date is not filled in, then it takes the value of the current date. (optional)
     * @param  string $dateFilter Defines on which fields the dates are filtered :   * If not specified, filters dates based on the validation date   * If &#x27;update&#x27;, filters dates based on the last modification date (either validation, update or answer) (optional)
     * @param  bool $picking Filter reviews awaiting proof. (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Immodvisor\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewListGetWithHttpInfo($checksum, $aPIVERSION, $companyId = null, $companyCustomId = null, $dateStart = null, $dateStop = null, $dateFilter = null, $picking = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse20010';
        $request = $this->reviewListGetRequest($checksum, $aPIVERSION, $companyId, $companyCustomId, $dateStart, $dateStop, $dateFilter, $picking);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse20010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewListGetAsync
     *
     * Get company's reviews list
     *
     * @param  string $checksum Request&#x27;s validity checksum (required)
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  int $companyId unique Immodvisor company ID (optional)
     * @param  string $companyCustomId Your unique company&#x27;s ID. (optional)
     * @param  string $dateStart start date of the search (YYYY-MM-DD : year + month + day). The date indicated is included. If the start date is not indicated, then it takes the value of the date of creation of the company on Immodvisor. (optional)
     * @param  string $dateStop Search&#x27;s end date (same format accepted). If the end date is not filled in, then it takes the value of the current date. (optional)
     * @param  string $dateFilter Defines on which fields the dates are filtered :   * If not specified, filters dates based on the validation date   * If &#x27;update&#x27;, filters dates based on the last modification date (either validation, update or answer) (optional)
     * @param  bool $picking Filter reviews awaiting proof. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewListGetAsync($checksum, $aPIVERSION, $companyId = null, $companyCustomId = null, $dateStart = null, $dateStop = null, $dateFilter = null, $picking = null)
    {
        return $this->reviewListGetAsyncWithHttpInfo($checksum, $aPIVERSION, $companyId, $companyCustomId, $dateStart, $dateStop, $dateFilter, $picking)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewListGetAsyncWithHttpInfo
     *
     * Get company's reviews list
     *
     * @param  string $checksum Request&#x27;s validity checksum (required)
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  int $companyId unique Immodvisor company ID (optional)
     * @param  string $companyCustomId Your unique company&#x27;s ID. (optional)
     * @param  string $dateStart start date of the search (YYYY-MM-DD : year + month + day). The date indicated is included. If the start date is not indicated, then it takes the value of the date of creation of the company on Immodvisor. (optional)
     * @param  string $dateStop Search&#x27;s end date (same format accepted). If the end date is not filled in, then it takes the value of the current date. (optional)
     * @param  string $dateFilter Defines on which fields the dates are filtered :   * If not specified, filters dates based on the validation date   * If &#x27;update&#x27;, filters dates based on the last modification date (either validation, update or answer) (optional)
     * @param  bool $picking Filter reviews awaiting proof. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewListGetAsyncWithHttpInfo($checksum, $aPIVERSION, $companyId = null, $companyCustomId = null, $dateStart = null, $dateStop = null, $dateFilter = null, $picking = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse20010';
        $request = $this->reviewListGetRequest($checksum, $aPIVERSION, $companyId, $companyCustomId, $dateStart, $dateStop, $dateFilter, $picking);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewListGet'
     *
     * @param  string $checksum Request&#x27;s validity checksum (required)
     * @param  string $aPIVERSION API&#x27;s Used version. (required)
     * @param  int $companyId unique Immodvisor company ID (optional)
     * @param  string $companyCustomId Your unique company&#x27;s ID. (optional)
     * @param  string $dateStart start date of the search (YYYY-MM-DD : year + month + day). The date indicated is included. If the start date is not indicated, then it takes the value of the date of creation of the company on Immodvisor. (optional)
     * @param  string $dateStop Search&#x27;s end date (same format accepted). If the end date is not filled in, then it takes the value of the current date. (optional)
     * @param  string $dateFilter Defines on which fields the dates are filtered :   * If not specified, filters dates based on the validation date   * If &#x27;update&#x27;, filters dates based on the last modification date (either validation, update or answer) (optional)
     * @param  bool $picking Filter reviews awaiting proof. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewListGetRequest($checksum, $aPIVERSION, $companyId = null, $companyCustomId = null, $dateStart = null, $dateStop = null, $dateFilter = null, $picking = null)
    {
        // verify the required parameter 'checksum' is set
        if ($checksum === null || (is_array($checksum) && count($checksum) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checksum when calling reviewListGet'
            );
        }
        // verify the required parameter 'aPIVERSION' is set
        if ($aPIVERSION === null || (is_array($aPIVERSION) && count($aPIVERSION) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $aPIVERSION when calling reviewListGet'
            );
        }

        $resourcePath = '/review/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($companyId !== null) {
            $queryParams['company_id'] = ObjectSerializer::toQueryValue($companyId, null);
        }
        // query params
        if ($companyCustomId !== null) {
            $queryParams['company_custom_id'] = ObjectSerializer::toQueryValue($companyCustomId, null);
        }
        // query params
        if ($dateStart !== null) {
            $queryParams['date_start'] = ObjectSerializer::toQueryValue($dateStart, null);
        }
        // query params
        if ($dateStop !== null) {
            $queryParams['date_stop'] = ObjectSerializer::toQueryValue($dateStop, null);
        }
        // query params
        if ($dateFilter !== null) {
            $queryParams['date_filter'] = ObjectSerializer::toQueryValue($dateFilter, null);
        }
        // query params
        if ($picking !== null) {
            $queryParams['picking'] = ObjectSerializer::toQueryValue($picking, null);
        }
        // query params
        if ($checksum !== null) {
            $queryParams['checksum'] = ObjectSerializer::toQueryValue($checksum, null);
        }
        // header params
        if ($aPIVERSION !== null) {
            $headerParams['APIVERSION'] = ObjectSerializer::toHeaderValue($aPIVERSION);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('APIKEY');
        if ($apiKey !== null) {
            $headers['APIKEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewListarchivedGet
     *
     * List of rejected or archived reviews
     *
     * @param  string $checksum request&#x27;s validity checksum (required)
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $companyId unique Immodvisor identifier of the company (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Immodvisor\Model\InlineResponse20011
     */
    public function reviewListarchivedGet($checksum, $aPIVERSION, $companyId = null)
    {
        list($response) = $this->reviewListarchivedGetWithHttpInfo($checksum, $aPIVERSION, $companyId);
        return $response;
    }

    /**
     * Operation reviewListarchivedGetWithHttpInfo
     *
     * List of rejected or archived reviews
     *
     * @param  string $checksum request&#x27;s validity checksum (required)
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $companyId unique Immodvisor identifier of the company (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Immodvisor\Model\InlineResponse20011, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewListarchivedGetWithHttpInfo($checksum, $aPIVERSION, $companyId = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse20011';
        $request = $this->reviewListarchivedGetRequest($checksum, $aPIVERSION, $companyId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse20011',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewListarchivedGetAsync
     *
     * List of rejected or archived reviews
     *
     * @param  string $checksum request&#x27;s validity checksum (required)
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $companyId unique Immodvisor identifier of the company (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewListarchivedGetAsync($checksum, $aPIVERSION, $companyId = null)
    {
        return $this->reviewListarchivedGetAsyncWithHttpInfo($checksum, $aPIVERSION, $companyId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewListarchivedGetAsyncWithHttpInfo
     *
     * List of rejected or archived reviews
     *
     * @param  string $checksum request&#x27;s validity checksum (required)
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $companyId unique Immodvisor identifier of the company (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewListarchivedGetAsyncWithHttpInfo($checksum, $aPIVERSION, $companyId = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse20011';
        $request = $this->reviewListarchivedGetRequest($checksum, $aPIVERSION, $companyId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewListarchivedGet'
     *
     * @param  string $checksum request&#x27;s validity checksum (required)
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $companyId unique Immodvisor identifier of the company (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewListarchivedGetRequest($checksum, $aPIVERSION, $companyId = null)
    {
        // verify the required parameter 'checksum' is set
        if ($checksum === null || (is_array($checksum) && count($checksum) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checksum when calling reviewListarchivedGet'
            );
        }
        // verify the required parameter 'aPIVERSION' is set
        if ($aPIVERSION === null || (is_array($aPIVERSION) && count($aPIVERSION) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $aPIVERSION when calling reviewListarchivedGet'
            );
        }

        $resourcePath = '/review/listarchived';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($companyId !== null) {
            $queryParams['company_id'] = ObjectSerializer::toQueryValue($companyId, null);
        }
        // query params
        if ($checksum !== null) {
            $queryParams['checksum'] = ObjectSerializer::toQueryValue($checksum, null);
        }
        // header params
        if ($aPIVERSION !== null) {
            $headerParams['APIVERSION'] = ObjectSerializer::toHeaderValue($aPIVERSION);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('APIKEY');
        if ($apiKey !== null) {
            $headers['APIKEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewUpdateAnswerPatch
     *
     * Edit an answer to a review
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $answerId answerId (optional)
     * @param  string $answer answer (optional)
     * @param  string $job job (optional)
     * @param  string $signature signature (optional)
     * @param  string $checksum checksum (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Immodvisor\Model\InlineResponse20013
     */
    public function reviewUpdateAnswerPatch($aPIVERSION, $answerId = null, $answer = null, $job = null, $signature = null, $checksum = null)
    {
        list($response) = $this->reviewUpdateAnswerPatchWithHttpInfo($aPIVERSION, $answerId, $answer, $job, $signature, $checksum);
        return $response;
    }

    /**
     * Operation reviewUpdateAnswerPatchWithHttpInfo
     *
     * Edit an answer to a review
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $answerId (optional)
     * @param  string $answer (optional)
     * @param  string $job (optional)
     * @param  string $signature (optional)
     * @param  string $checksum (optional)
     *
     * @throws \Immodvisor\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Immodvisor\Model\InlineResponse20013, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewUpdateAnswerPatchWithHttpInfo($aPIVERSION, $answerId = null, $answer = null, $job = null, $signature = null, $checksum = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse20013';
        $request = $this->reviewUpdateAnswerPatchRequest($aPIVERSION, $answerId, $answer, $job, $signature, $checksum);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse20013',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Immodvisor\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewUpdateAnswerPatchAsync
     *
     * Edit an answer to a review
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $answerId (optional)
     * @param  string $answer (optional)
     * @param  string $job (optional)
     * @param  string $signature (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewUpdateAnswerPatchAsync($aPIVERSION, $answerId = null, $answer = null, $job = null, $signature = null, $checksum = null)
    {
        return $this->reviewUpdateAnswerPatchAsyncWithHttpInfo($aPIVERSION, $answerId, $answer, $job, $signature, $checksum)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewUpdateAnswerPatchAsyncWithHttpInfo
     *
     * Edit an answer to a review
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $answerId (optional)
     * @param  string $answer (optional)
     * @param  string $job (optional)
     * @param  string $signature (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewUpdateAnswerPatchAsyncWithHttpInfo($aPIVERSION, $answerId = null, $answer = null, $job = null, $signature = null, $checksum = null)
    {
        $returnType = '\Immodvisor\Model\InlineResponse20013';
        $request = $this->reviewUpdateAnswerPatchRequest($aPIVERSION, $answerId, $answer, $job, $signature, $checksum);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewUpdateAnswerPatch'
     *
     * @param  string $aPIVERSION API&#x27;s used version. (required)
     * @param  int $answerId (optional)
     * @param  string $answer (optional)
     * @param  string $job (optional)
     * @param  string $signature (optional)
     * @param  string $checksum (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewUpdateAnswerPatchRequest($aPIVERSION, $answerId = null, $answer = null, $job = null, $signature = null, $checksum = null)
    {
        // verify the required parameter 'aPIVERSION' is set
        if ($aPIVERSION === null || (is_array($aPIVERSION) && count($aPIVERSION) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $aPIVERSION when calling reviewUpdateAnswerPatch'
            );
        }

        $resourcePath = '/review/update-answer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($aPIVERSION !== null) {
            $headerParams['APIVERSION'] = ObjectSerializer::toHeaderValue($aPIVERSION);
        }


        // form params
        if ($answerId !== null) {
            $formParams['answer_id'] = ObjectSerializer::toFormValue($answerId);
        }
        // form params
        if ($answer !== null) {
            $formParams['answer'] = ObjectSerializer::toFormValue($answer);
        }
        // form params
        if ($job !== null) {
            $formParams['job'] = ObjectSerializer::toFormValue($job);
        }
        // form params
        if ($signature !== null) {
            $formParams['signature'] = ObjectSerializer::toFormValue($signature);
        }
        // form params
        if ($checksum !== null) {
            $formParams['checksum'] = ObjectSerializer::toFormValue($checksum);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('APIKEY');
        if ($apiKey !== null) {
            $headers['APIKEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
